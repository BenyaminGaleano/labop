/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package labop;

import java.io.File;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.function.Function;

import labop.config.ConfigParser;
import labop.csv.CSVWatcher;
import labop.display.Display;

public class App {

	private Display display;
	private Scanner scan;
	private AppMode mode;

	private App(Display display, Scanner scan, AppMode mode) {
		this.display = display;
		this.scan = scan;
		this.mode = mode;
	}

	private void linear(CSVWatcher input, CSVWatcher notas, CSVWatcher comentarios) {
		display.msg(input.settings.get("scheme", String.class));
	}

	private void search(CSVWatcher input, CSVWatcher notas, CSVWatcher comentarios) {
		display.msg("Modo Busqueda Activo");
	}

	private void start() {
		File infile = new File("input/");
		File outfile = new File("output/");

		if(!infile.exists()) 
			infile.mkdir();
		if(!outfile.exists())
			outfile.mkdir();

		ConfigParser inconf = null;
		ConfigParser outconf = null;

		try {
			inconf = new ConfigParser("input.yaml");
			outconf = new ConfigParser("output.yaml");
		} catch (Exception e) {
			display.error("los archivos de configuración son obligatorios");
		}

		CSVWatcher input = new CSVWatcher(inconf, infile.listFiles((file, fname) -> fname.matches(".*\\.csv")));
		int width = inconf.get("exercises", Integer.class);
		int height = input.csvs.firstEntry().getValue().size() - inconf.get("startline", Integer.class);
		CSVWatcher notas = new CSVWatcher(outconf, new File("output/notas.csv"), width, height);
		CSVWatcher comments = new CSVWatcher(outconf, new File("output/comentarios.csv"), width, height);

		String delimiter1 = inconf.get("scheme", String.class);
		String delimiter2 = delimiter1.split("\\*")[2].trim();
		delimiter1 = delimiter1.split("\\*")[1].trim();

		LinkedList<Section> trace = new LinkedList<>();

		int countId = 0;
		int endpoint, startpoint;
		String name = null;
		int points = 0;
		for (String celda : input.csvs.firstEntry().getValue().get(inconf.get("startline", Integer.class)-1)) {
			if (countId++ >= inconf.get("idCol", Integer.class) && countId < inconf.get("idCol", Integer.class)+inconf.get("exercises", Integer.class)+1) {
				endpoint = 0;
				startpoint = 0;
				for (; endpoint < celda.length(); endpoint++) {
					if (celda.charAt(endpoint) == delimiter1.charAt(0)) {
						name = celda.substring(startpoint, endpoint).trim();
						startpoint = endpoint+1;
					} else if (celda.charAt(endpoint) == delimiter2.charAt(0)) {
						points = Integer.parseInt(celda.substring(startpoint, endpoint).trim());
					}
				}
				trace.add(new Section(points, name));
			}
		}

		System.out.println(trace);

		switch (mode) {
			case linear:
				linear(input, notas, comments);
				break;
		
			case search:
				search(input, notas, comments);
				break;
		}
	}

    public static void main(String[] args) {

    	/*Creación de display*/
    	ConfigParser displayconf = null;

    	try{
    		displayconf = new ConfigParser("display.yaml");
    	} catch(Exception e){
    		e.printStackTrace();
    	}

    	Display display = new Display(displayconf);

    	display.show("\nHerramienta auxiliar para calificar\n\n", Display.YELLOW);

    	display.msg("Seleccione modo de ejecución.\n\t1. Linear\n\t2. Busqueda");
    	display.show("# ", Display.BLUE);

		Scanner scan = new Scanner(System.in);
		String op = "";
		
		while (!(op = scan.nextLine()).matches("1|2")) {
			display.error("sólo puede ingresar 1 o 2");
			display.show("# ", Display.BLUE);
		}

		AppMode mode = null;
		switch (op) {
			case "1":
				display.msg("Modo Lineal Activo");
				mode = AppMode.linear;
				break;
		
			case "2":
				display.msg("Modo Búsqueda Activo");
				mode = AppMode.search;
				break;
		}

		App tool = new App(display, scan, mode);
		tool.start();

    	scan.close();
	}
}

enum AppMode { linear, search }

class Section {
	final int points;
	final String name;

	public Section(int points, String name) {
		this.points = points;
		this.name = name;
	}

	@Override
	public String toString() {
		return "N: " + name + " P: " + points;
	}
}
