/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package labop;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.util.LinkedList;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.stream.Collectors;

import labop.config.ConfigParser;
import labop.csv.CSVWatcher;
import labop.display.Display;

public class App {

	private Display display;
	private Scanner scan;
	private LogBuilder logBuilder;

	private App(Display display, Scanner scan) {
		this.display = display;
		this.scan = scan;
	}

	private void changeEncoding(File file) {
		try {
			FileInputStream infile = new FileInputStream(file);
			InputStreamReader readerin = new InputStreamReader(infile, "ISO-8859-1");
			BufferedReader in = new BufferedReader(readerin);
			StringBuilder buff = new StringBuilder();
			int aux;
			while ((aux = in.read()) != -1)
				buff.append((char) aux);
			File fileRelease = new File(file.getParent()+"/"+file.getName().replaceAll("[.]csv", "")+"-SUBIR.csv");
			if(fileRelease.exists()) fileRelease.delete();
			FileOutputStream stream = new FileOutputStream(fileRelease);
			stream.write(buff.toString().getBytes());
			stream.close();
			in.close();
		} catch (IOException e) {
			e.printStackTrace();
		} 
	}

	private void recoveryLinear(File log, LinkedList<Section> trace) {
		try {
			Scanner reader = new Scanner(log);
			// comentario <#> punteo
			String aux = "";
			reader.nextLine();

			for (Section section : trace) {
				if (!reader.hasNext())
					break;
				aux = reader.nextLine();
				if (aux.isEmpty())
					break;
				section.set(Integer.parseInt(aux.split("<#>")[1].trim()), aux.split("<#>")[0].trim());
			}
			reader.close();
		} catch (FileNotFoundException e) {
			display.error("no se pudo leer el log");
		}
	}

	private void writeLog(File log) {
		try {
			FileOutputStream out = new FileOutputStream(log);
			out.write(logBuilder.tobytes());
			out.close();
		} catch (IOException e) {
			display.error("no se pudo escribir LOG");
		}
	}

	private void writeAndConfirm(ConfigParser inconf, CSVWatcher notas, CSVWatcher comentarios, AtomicInteger count, LinkedList<Section> trace, LinkedList<String> row) {
		notas.writeRow(count.get(), trace.stream().map(sec -> {
			return sec.total + "";
		}).collect(Collectors.toCollection(LinkedList::new)));
		String aux = "";
		for (Section sec : trace) {
			if (sec.comment.trim().isEmpty())
				continue;
			aux += sec.name + ") " + sec.comment + " ";
		}

		String commto = "\"" + aux.trim() + "\"";
		comentarios.writeRow(count.get(), new LinkedList<String>() {
			private static final long serialVersionUID = 1L;
			{
				add(commto);
			}
		});

		display.show("Alumno: " + row.get(inconf.get("idCol", Integer.class) - 1) + " Nota: " + trace.stream().map((sc)-> sc.total).reduce((a,b)->a+b).orElseGet(()->0) + "\n", Display.GREEN);

		notas.rewrite();
		comentarios.rewrite();
		trace.forEach(sec -> {
			sec.reset();
		});
		display.show("\n(enter)", Display.RESET);
		scan.nextLine();
	}

	private void reflect(CSVWatcher input, CSVWatcher notas, CSVWatcher comentarios) {
		changeEncoding(comentarios.csvs.firstKey());
		File gesDir = new File("ges/");
		File bindDir = new File("bind/");

		ConfigParser gesconf = null;
		ConfigParser bindconf = null;

		try {
			gesconf = new ConfigParser("ges.yaml");
			bindconf = new ConfigParser("bind.yaml");
		} catch (Exception e) {
			display.error("No se puede proseguir porque faltan los archivos de configuración");
			return;
		}

		if (gesDir.exists()) {
			display.inf("Carpeta ges encontrada");
		} else return;

		if (!gesconf.get("glue", Boolean.class)) {
			display.inf("Has indicado que no se necesitan archivos enlace");
		} else if (bindDir.exists()) {
			display.inf("Carpeta bind encontrada");
		} else {
			display.error("No se pudo proseguir porque no existe la carpeta bind");
			return;
		}

		display.msg("Iniciando copia hacia el archivo del ges");

		CSVWatcher gWatcher = new CSVWatcher(gesconf, gesDir.listFiles((file, fname) -> fname.matches(".*\\.csv")));
		CSVWatcher bWatcher = new CSVWatcher(bindconf, bindDir.listFiles((file, fname) -> fname.matches(".*\\.csv")));

		AtomicInteger count = new AtomicInteger();

		LinkedList<String> calificaciones = notas.csvs.firstEntry().getValue()
			.stream().map((row)-> row.stream()
				.map((nst) -> Integer.parseInt(nst))
				.reduce((a,b)-> a+b)
				.orElseGet(()->0))
			.map((nt)->nt.toString())
			.collect(Collectors.toCollection(LinkedList::new));
		LinkedList<String> comments = comentarios.csvs.firstEntry().getValue()
			.stream().map((row)->row.get(0))
			.collect(Collectors.toCollection(LinkedList::new));

		input.consumeCSVs((student) -> {
			int stdNum = count.getAndIncrement();
			String carnet = student.get(input.settings.get("idCol", Integer.class)-1);
			LinkedList<String> stbind = bWatcher.search("keyCol", carnet);

			if (!gWatcher.settings.get("glue", Boolean.class)) {
				stbind = new LinkedList<>();
				stbind.add(carnet);
			} else if (stbind == null) {
				display.warning("no existe "+carnet+" en los archivos de bind");
				return;
			}
			
			TreeMap<String,String> info = new TreeMap<>();
			info.put("gradeCol", calificaciones.get(stdNum));
			info.put("commentCol", comments.get(stdNum).length() > gWatcher.settings.get("maxcommentsize", Integer.class) ? gWatcher.settings.get("comment", String.class) : comments.get(stdNum));

			if (gWatcher.writeAndGet(info, "idCol", stbind.get(1), "gradeCol") == null) {
				display.warning("El alumno "+carnet+" no fue encontrado en los archivos del ges");
			}
		});

		gWatcher.rewrite();
		display.msg("cambiando codificación");
		if(gWatcher.csvs.size() > 0)
			changeEncoding(gWatcher.csvs.firstKey());
		display.msg("copia terminada :)");
	}

	private void linear(CSVWatcher input, CSVWatcher notas, CSVWatcher comentarios, LinkedList<Section> trace) {
		final ConfigParser inconf = input.settings;
		final ConfigParser outconf = notas.settings;
		AtomicInteger count = new AtomicInteger();
		File log = new File("input/log.log");
		AtomicInteger start = new AtomicInteger();
		AtomicBoolean close = new AtomicBoolean();

		logBuilder = new LogBuilder(0, trace);

		if (log.exists()) {
			recoveryLinear(log, trace);
			try {
				Scanner reader = new Scanner(log);
				start.set(reader.nextInt());
				reader.close();
			} catch (FileNotFoundException e) {
				display.error("No se pudo recuperar el estado :c");
			}
		}

		input.consumeCSVs((row) -> {
			if (close.get())
				return;
			if (count.incrementAndGet() < start.get())
				return;
			
			logBuilder.studentLine = count.get();
			writeLog(log);

			display.show("\n\nAlumno: " + row.get(inconf.get("idCol", Integer.class) - 1) + "\n", Display.YELLOW);

			Section section;
			int prev = 0;
			for (int i = 0; i < trace.size(); i++) {
				if (trace.get(i).fill())
					prev = i + 1;
			}

			process: for (int i = prev; i < trace.size(); i++) {

				section = trace.get(i);

				display.show("\nEjercicio: " + section.name + "\nvalor: " + section.points + "\n", Display.YELLOW);

				String command;

				readcommand: while (true) {
					display.show("\n# ", Display.BLUE);
					command = scan.nextLine();
					// comandos

					switch (command.trim().split(" ")[0]) {
						case "close":
							close.set(true);
							display.msg("Hasta luego " + System.getProperty("user.name"));
							return;

						case "prev":
							int aux00 = i;
							i = prev - 1;
							prev = aux00;
							continue process;

						case "next":
							prev = i;
							if (i+1 == trace.size()) {
								prev = 0;
							} 
							continue process;

						case "exit":
							return;

						case "goto":
							Scanner cmdscan = new Scanner(command);
							int aux01 = i;
							cmdscan.next();
							String sect00 = cmdscan.nextLine().trim();
							for (int j = 0; j < trace.size(); j++) {
								if (trace.get(j).name.toLowerCase().trim().equals(sect00.toLowerCase())) {
									prev = i;
									i = j - 1;
								}
							}
							if (i + 1 == aux01) {
								display.warning("No se encontró la sección que pidió");
								continue readcommand;
							}
							cmdscan.close();
							continue process;

						case "finish":
							if (outconf.get("fill", Boolean.class)) {
								String comentario = outconf.get("comment", String.class);
								LinkedList<LinkedList<String>> nots = notas.csvs.firstEntry().getValue();
								LinkedList<LinkedList<String>> comentaris = comentarios.csvs.firstEntry().getValue();
								for (int j = 0; j < nots.size(); j++) {
									if (nots.get(j).stream().reduce((a,b) -> a+b).orElseGet(() -> "").isEmpty()) {
										for (int k = 0; k < nots.get(j).size(); k++) {
											nots.get(j).set(k, "0");
										}
										comentaris.get(j).set(0, comentario);
									}
								}
								notas.rewrite();
								comentarios.rewrite();
							}
							log.delete();
							close.set(true);
							display.msg("Bien hecho " + System.getProperty("user.name") + " terminaste :3");
							reflect(input, notas, comentarios);
							return;

						case "set":
							String content = command.trim().split(" ")[1];
							int nota = 0;
							if (content.toLowerCase().equals("max")) {
								trace.forEach((sec) -> sec.total = sec.points);
							} else {
								try {
									nota = Integer.parseInt(content);
								} catch (Exception e){
									display.error("nota no válida");
									continue readcommand;
								}
								final int nota00 =  nota;
								trace.forEach((sec) -> sec.total = nota00);
							}

							display.show("// ", Display.BLUE);
							String aux02 = scan.nextLine();

							String commto = "\"" + aux02.trim() + "\"";
							comentarios.writeRow(count.get(), new LinkedList<String>() {
								private static final long serialVersionUID = 1L;
								{
									add(commto);
								}
							});
							notas.writeRow(count.get(), trace.stream().map(sec -> {
								return sec.total + "";
							}).collect(Collectors.toCollection(LinkedList::new)));
							display.show("Alumno: " + row.get(inconf.get("idCol", Integer.class) - 1) + " Nota: " + trace.stream().map((sc)-> sc.total).reduce((a,b)->a+b).orElseGet(()->0) + "\n", Display.GREEN);
							trace.forEach((sec) -> sec.reset());

							notas.rewrite();
							comentarios.rewrite();
							display.show("\n(enter)", Display.RESET);
							scan.nextLine();
							return;

						case "":
							prev = i;
							break readcommand;

						default:
							display.error("comando inválido");
							continue readcommand;
					}
				}

				// calificar
				display.show("// ", Display.BLUE);
				String comentario = scan.nextLine();
				display.show("P: ", Display.BLUE);
				int points = scan.nextInt();
				scan.nextLine();
				section.total = points;
				section.comment = comentario;
				writeLog(log);
			}

			writeAndConfirm(inconf, notas, comentarios, count, trace, row);
		});
	}

	private void search(CSVWatcher input, CSVWatcher notas, CSVWatcher comentarios, LinkedList<Section> trace) {
		final ConfigParser inconf = input.settings;
		final ConfigParser outconf = notas.settings;
		AtomicInteger count = new AtomicInteger();
		File log = new File("input/log.log");
		AtomicInteger start = new AtomicInteger();
		AtomicBoolean backup = new AtomicBoolean();
		AtomicBoolean close = new AtomicBoolean();
		display.show("\n", Display.BLUE);
		display.inf("el prefijo & indica buscador. Escriba el carnet o enter para ir al primero");

		logBuilder = new LogBuilder(0, trace);

		if (log.exists()) {
			recoveryLinear(log, trace);
			backup.set(true);
			try {
				Scanner reader = new Scanner(log);
				start.set(reader.nextInt());
				reader.close();
			} catch (FileNotFoundException e) {
				display.error("No se pudo recuperar el estado :c");
			}
		}

		LinkedList<String> row;

		search: while(true) {
			if (close.get())
				return;
			
			if (backup.get()) {
				row = input.csvs.firstEntry().getValue().get(inconf.get("startline", Integer.class) - 2 + start.get());
				count.set(start.get());
				backup.set(false);
			} else {
				display.show("\n& ", Display.BLUE);
				String carnet = scan.nextLine();
				if ( !carnet.isEmpty() ) {
					row = input.search("idCol", carnet);
					if (row == null){
						display.warning("No existe ningún estudiante asociado con ese carnet");
						continue search;
					}
					count.set(input.lastvisit -  inconf.get("startline", Integer.class) + 2);
				} else {
					row = input.csvs.firstEntry().getValue().getFirst();
					count.set(1);
				}
			}
			
			logBuilder.studentLine = count.get();

			display.show("\n\nAlumno: " + row.get(inconf.get("idCol", Integer.class) - 1) + "\n", Display.YELLOW);

			Section section;
			int prev = 0;
			for (int i = 0; i < trace.size(); i++) {
				if (trace.get(i).fill())
					prev = i + 1;
			}

			process: for (int i = prev; i < trace.size(); i++) {

				section = trace.get(i);

				display.show("\nEjercicio: " + section.name + "\nvalor: " + section.points + "\n", Display.YELLOW);

				String command;

				readcommand: while (true) {
					display.show("\n# ", Display.BLUE);
					command = scan.nextLine();
					// comandos

					switch (command.trim().split(" ")[0]) {
						case "close":
							close.set(true);
							display.msg("Hasta luego " + System.getProperty("user.name"));
							break search;

						case "prev":
							int aux00 = i;
							i = prev - 1;
							prev = aux00;
							continue process;

						case "next":
							prev = i;
							if (i+1 == trace.size()) {
								prev = 0;
							} 
							continue process;

						case "exit":
							continue search;

						case "goto":
							Scanner cmdscan = new Scanner(command);
							int aux01 = i;
							cmdscan.next();
							String sect00 = cmdscan.nextLine().trim();
							for (int j = 0; j < trace.size(); j++) {
								if (trace.get(j).name.toLowerCase().trim().equals(sect00.toLowerCase())) {
									prev = i;
									i = j - 1;
								}
							}
							if (i + 1 == aux01) {
								display.warning("No se encontró la sección que pidió");
								continue readcommand;
							}
							cmdscan.close();
							continue process;

						case "finish":
							if (outconf.get("fill", Boolean.class)) {
								String comentario = outconf.get("comment", String.class);
								LinkedList<LinkedList<String>> nots = notas.csvs.firstEntry().getValue();
								LinkedList<LinkedList<String>> comentaris = comentarios.csvs.firstEntry().getValue();
								for (int j = 0; j < nots.size(); j++) {
									if (nots.get(j).stream().reduce((a,b) -> a+b).orElseGet(() -> "").isEmpty()) {
										for (int k = 0; k < nots.get(j).size(); k++) {
											nots.get(j).set(k, "0");
										}
										comentaris.get(j).set(0, comentario);
									}
								}
								notas.rewrite();
								comentarios.rewrite();
							}
							log.delete();
							display.msg("Bien hecho " + System.getProperty("user.name") + " terminaste :3");
							reflect(input, notas, comentarios);
							break search;

						case "set":
							String content = command.trim().split(" ")[1];
							int nota = 0;
							if (content.toLowerCase().equals("max")) {
								trace.forEach((sec) -> sec.total = sec.points);
							} else {
								try {
									nota = Integer.parseInt(content);
								} catch (Exception e){
									display.error("nota no válida");
									continue readcommand;
								}
								final int nota00 =  nota;
								trace.forEach((sec) -> sec.total = nota00);
							}

							display.show("// ", Display.BLUE);
							String aux02 = scan.nextLine();

							String commto = "\"" + aux02.trim() + "\"";
							comentarios.writeRow(count.get(), new LinkedList<String>() {
								private static final long serialVersionUID = 1L;
								{
									add(commto);
								}
							});
							notas.writeRow(count.get(), trace.stream().map(sec -> {
								return sec.total + "";
							}).collect(Collectors.toCollection(LinkedList::new)));
							display.show("Alumno: " + row.get(inconf.get("idCol", Integer.class) - 1) + " Nota: " + trace.stream().map((sc)-> sc.total).reduce((a,b)->a+b).orElseGet(()->0) + "\n", Display.GREEN);
							trace.forEach((sec) -> sec.reset());
							log.delete();
							notas.rewrite();
							comentarios.rewrite();
							display.show("\n(enter)", Display.RESET);
							scan.nextLine();
							continue search;

						case "":
							prev = i;
							break readcommand;

						default:
							display.error("comando inválido");
							continue readcommand;
					}
				}

				// calificar
				display.show("// ", Display.BLUE);
				String comentario = scan.nextLine();
				display.show("P: ", Display.BLUE);
				int points = scan.nextInt();
				scan.nextLine();
				section.total = points;
				section.comment = comentario;
				writeLog(log);
			}

			writeAndConfirm(inconf, notas, comentarios, count, trace, row);
			log.delete();
		}
	}

	private void start() {
		File infile = new File("input/");
		File outfile = new File("output/");

		if (!infile.exists())
			infile.mkdir();
		if (!outfile.exists())
			outfile.mkdir();

		ConfigParser inconf = null;
		ConfigParser outconf = null;

		try {
			inconf = new ConfigParser("input.yaml");
			outconf = new ConfigParser("output.yaml");
		} catch (Exception e) {
			display.error("los archivos de configuración son obligatorios");
		}

		CSVWatcher input = new CSVWatcher(inconf, infile.listFiles((file, fname) -> fname.matches(".*\\.csv")));

		File notf = new File("output/notas.csv");
		File comf = new File("output/comentarios.csv");
		CSVWatcher notas = null;
		CSVWatcher comments = null;

		if (!notf.exists()) {
			int width = inconf.get("exercises", Integer.class);
			int height = input.csvs.firstEntry().getValue().size() - (inconf.get("startline", Integer.class) - 1);
			notas = new CSVWatcher(outconf, notf, width, height);
			comments = new CSVWatcher(outconf, comf, 1, height);
		} else {
			notas = new CSVWatcher(outconf, notf);
			comments = new CSVWatcher(outconf, comf);
			System.out.println();
			display.warning("hay archivos en la carpeta output, tenga cuidado!!");
			display.show("Esquema de los archivos en output", Display.BLUE);
			display.show("\n\tnotas.csv: \n\t\tfilas: "+notas.csvs.firstEntry().getValue().size()+"\n\t\tcolumnas: "+notas.csvs.firstEntry().getValue().getFirst().size()+"\n", Display.BLUE);
			display.show("\tcomentarios.csv: \n\t\tfilas: "+comments.csvs.firstEntry().getValue().size()+"\n\t\tcolumnas: "+comments.csvs.firstEntry().getValue().getFirst().size()+"\n", Display.BLUE);
		}

		String delimiter1 = inconf.get("scheme", String.class);
		String delimiter2 = delimiter1.split("\\*")[2].trim();
		delimiter1 = delimiter1.split("\\*")[1].trim();

		LinkedList<Section> trace = new LinkedList<>();

		int countId = 0;
		int endpoint, startpoint;
		String name = null;
		int points = 0;

		ConcurrentLinkedQueue<Integer> mul = new ConcurrentLinkedQueue<>();

		for (String mult : inconf.get("partitions", String.class).split(" ")) {
			mul.add(Integer.parseInt(mult));
		}

		ConcurrentLinkedQueue<String> sections = new ConcurrentLinkedQueue<>();
		for (String celda : input.csvs.firstEntry().getValue().get(inconf.get("startline", Integer.class) - 4)) {
			if (countId++ >= inconf.get("idCol", Integer.class)
					&& countId < inconf.get("idCol", Integer.class) + inconf.get("exercises", Integer.class) + 1) {
				if (!celda.trim().isEmpty()) {
					for (int i = 0, aux = mul.poll(); i < aux; i++) {
						sections.add(celda.trim());
					}
				}
			}
		}

		countId = 0;

		for (String celda : input.csvs.firstEntry().getValue().get(inconf.get("startline", Integer.class) - 2)) {
			if (countId++ >= inconf.get("idCol", Integer.class)
					&& countId < inconf.get("idCol", Integer.class) + inconf.get("exercises", Integer.class) + 1) {
				endpoint = 0;
				startpoint = 0;
				for (; endpoint < celda.length(); endpoint++) {
					if (celda.charAt(endpoint) == delimiter1.charAt(0)) {
						name = sections.poll() + "-" + celda.substring(startpoint, endpoint).trim();
						startpoint = endpoint + 1;
					} else if (celda.charAt(endpoint) == delimiter2.charAt(0)) {
						points = Integer.parseInt(celda.substring(startpoint, endpoint).trim());
					}
				}
				if (name == null) {
					name = sections.poll();
				}
				trace.add(new Section(points, name));
				name = null;
			}
		}

		display.show("\nHerramienta auxiliar para calificar\n\n", Display.YELLOW);

		display.msg("Seleccione modo de ejecución.\n\t1. Linear\n\t2. Busqueda");
		display.show("# ", Display.BLUE);
		
		String op = "";

		while (!(op = scan.nextLine()).matches("1|2")) {
			display.error("sólo puede ingresar 1 o 2");
			display.show("# ", Display.BLUE);
		}

		AppMode mode = null;
		switch (op) {
			case "1":
				display.msg("Modo Lineal Activo");
				mode = AppMode.linear;
				break;

			case "2":
				display.msg("Modo Búsqueda Activo");
				mode = AppMode.search;
				break;
		}

		display.inf("el prefijo // es para comentarios");
		display.inf("el prefijo P: es para el puntaje");
		display.inf("el prefijo # indica consola utilice los siguientes comandos:");
		display.show("goto SECCIÓN (indique el nombre a la seccion a la que quiere saltar)\n", Display.GREEN);
		display.show("prev (ir al ejercicio previamente visitado)}\n", Display.GREEN);
		display.show("next (ir al siguiente)\n", Display.GREEN);
		display.show("exit (sale del estudiante y se pierden los datos)\n", Display.GREEN);
		display.show("close (para el programa)\n", Display.GREEN);
		display.show("set NOTA (califica todas las secciones con esa nota, set max con la máxima nota por sección)\n", Display.GREEN);
		display.show("finish (se terminó de calificar - modo búsqueda\n", Display.GREEN);
		display.show("(presione enter para proseguir)", Display.GREEN);

		switch (mode) {
			case linear:
				linear(input, notas, comments, trace);
				break;

			case search:
				search(input, notas, comments, trace);
				break;
		}
	}

	public static void main(String[] args) {

		/* Creación de display */
		ConfigParser displayconf = null;

		try {
			displayconf = new ConfigParser("display.yaml");
		} catch (Exception e) {
			e.printStackTrace();
		}

		Display display = new Display(displayconf);

		Scanner scan = new Scanner(System.in);

		App tool = new App(display, scan);
		tool.start();

		scan.close();
	}
}

enum AppMode {
	linear, search
}

class Section {
	final int points;
	final String name;
	int total;
	String comment;

	public Section(int points, String name) {
		this.points = points;
		this.name = name;
		this.total = 0;
		this.comment = "";
	}

	public void reset() {
		this.total = 0;
		this.comment = "";
	}

	public void set(int total, String comment) {
		this.total = total;
		this.comment = comment;
	}

	public boolean fill() {
		return !this.comment.trim().isEmpty() || this.total > 0;
	}

	@Override
	public String toString() {
		return "N: " + name + " P: " + points + " T:" + total;
	}
}

class LogBuilder {
	final LinkedList<Section> trace;
	int studentLine;

	public LogBuilder(int studentLine, LinkedList<Section> trace) {
		this.trace = trace;
		this.studentLine = studentLine;
	}

	public byte[] tobytes() throws UnsupportedEncodingException {
		StringBuilder logBuilder = new StringBuilder();
		logBuilder.append(studentLine);
		logBuilder.append('\n');
		trace.forEach((section) -> {
			logBuilder.append(section.comment + "<#>" + section.total);
			logBuilder.append('\n');
		});
		return logBuilder.toString().getBytes();
	}
}
